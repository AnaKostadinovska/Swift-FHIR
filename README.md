FHIR Swift Classes
==================

These are [Swift](https://developer.apple.com/swift/) classes representing data models of [FHIR](http://hl7.org/implement/standards/fhir/) resources.
Classes are generated by [fhir-parser](https://github.com/smart-on-fhir/fhir-parser), currently from DSTU1 (0.0.82.2943).
Releases will be tagged accordingly.

Written in _Swift_ the classes are compatible with **iOS 7** and **OS X 10.9** and later.
Building Swift frameworks requires Xcode 6 or later.


SMART on FHIR
-------------

The [SMART on FHIR](https://github.com/p2/SMART-on-FHIR-Cocoa) Cocoa framework utilizes these classes.
It also adds an implementation of this repo's _FHIRServer_ protocol to make the classes fully usable.


Progress
--------

Here's a rough list of what should be done.
Things that have an `X` are done in the sense that they work but have not necessarily been tested extensively.

```
[X] Create classes for all FHIR profiles/resources from spec
[X] Write deserializer that instantiates from JSON
[X] Reference resolver: resolve contained resources
[ ] Reference resolver: resolve remote resources
[~] Construct search URL parameters in code with properties (see below)
[ ] Construct search URL parameters with NoSQL-like constructs
[ ] Create a default behavior when a modifierExtension is detected
[ ] Use non-optional properties and implement failable initializers (see @smart-on-fhir/fhir-parser:feature/swift-failable-init)
[ ] Improve the Extension resource (see below)
[ ] Write serializer
[ ] Validate serialized JSON?
[x] Write unit tests that use the example JSONs
[ ] Write a real nice documentation
```


Class Generation
----------------

Class generation is achieved with our [Python FHIR parser](https://github.com/smart-on-fhir/fhir-parser).

### Verbousness

Swift is **statically typed** and introspection is _very_ limited at the time.
Therefore the generator needs to be a bit more verbose and create class-level serializers/deserializers, rather than looking at class properties at runtime and figure out how to serialize/deserialize.

### Cardinality

Some data models have properties with a cardinality of a minimum of 1.
While these can be enforced to never be nil in Swift by **not** making them _Optionals_, they are made optional to enable uniform initializers that only take a JSON dictionary.
For classes representing models with non-optional properties, a convenience initializer is supplied to reflect the need to set those properties without enforcing it.

### Contained Resources

FHIR makes use of [contained resources](http://hl7.org/implement/standards/fhir/references.html#contained).
Such properties are represented as `FHIRReference` instances, a subclass of FHIR's `ResourceReference`.
To resolve resource references, call `resolved()` on a FHIRReference property, which will return an instance of the referenced type, if resolving was successful.


Extensions
----------

All FHIR resources can have one or more [_Extension_](http://hl7.org/implement/standards/fhir/extensibility.html#extension) elements as their `extension` property. Two remarks:

- Since **`extension` is a Swift keyword**, this property has been renamed to `fhirExtension`.
- The actual extension element has one property named **`value[x]`**, with the _[x]_ part replaced with their CamelCased type.
    The generator currently creates one `value` property of type `FHIRElement`, our superclass.
    This should be improved, probably by creating all possible `value[x]` properties.


Search
------

> Search is **work in progress**.

There is **preliminary** support for creating search query URLs in an object-oriented way.
Using the `search()` method on either a FHIRResource instance or on a class itself returns a `FHIRSearchParam` instance, which has methods for all currently defined search params.
These method calls can be chained and will eventually support all possible parameter combinations.

Calling the `construct()` method on the _last_ search parameter will construct the URL query that can be used to perform the search on a FHIR server:

```swift
let id = "1288992"
let path = MedicationPrescription.search().patient(id).construct()
// path now is: MedicationPrescription?patient=1288992
fhir_server.requestJSON(path) { json, error in
    // ...
}
```

There is a convenience method to construct the search URL and request data from the server in one go:

```swift
let id = "1288992"
MedicationPrescription.search().patient(id).perform(fhir_server) {
    results, error in
    // on success `results` is an array of MedicationPrescriptions
    // ...
}
```

Some examples of what we need to construct:

```
[X] Patient?name=eve
    Patient.search().name("eve")

[X] Patient?name:exact=Eve
    Patient.search().name(exact: "Eve")

[X] Patient?gender=male
    Patient.search().gender("male")

[~] Patient?gender=http://hl7.org/fhir/v2/0001|M
    Patient.search().gender("http://hl7.org/fhir/v2/0001|M")
 !  Patient.search().gender("http://hl7.org/fhir/v2/0001", "M")

[X] Patient?gender:text=male
    Patient.search().gender(asText: "male")

[X] Patient?gender:missing=true
    Patient.search().gender(missing: true)

[ ] Patient?language=FR,NL              // French or Dutch
    Patient.search().language("FR", "NL")

[X] Patient?language=FR&language=NL     // French and Dutch
    Patient.search().language("FR").language("NL")

[X] Condition?date-asserted=2014-03
    Condition.search().dateAsserted("2014-03")

[ ] DiagnosticReport?subject:Patient=23
    DiagnosticReport.search().subject(???)

[ ] DiagnosticReport?subject.name=peter
    DiagnosticReport.search().???

[ ] DiagnosticReport?subject:Patient.name=peter
    DiagnosticReport.search().???

[~] Observation?value-quantity=<5.4|http://unitsofmeasure.org|mg
    Observation.search().valueQuantity("<5.4|http://unitsofmeasure.org|mg")
 !  Observation.search().valueQuantity("<5.4", "mg")

...
```

#### Compartments

Search can be restricted to [compartments](http://hl7.org/implement/standards/fhir/extras.html#compartment), these however are not yet supported in the SMART server nor in these classes.

```
[ ] Patient/23/procedure?date=>2010-01-01&date=<2011-12-31
```

#### Referenced (not yet implemented)

If search is restricted to a reference property, this applies:

- If the search token is merely an id, i.e. it does **not** contain a forward slash, a type restricted search is constructed based on which instance method is called:
    `GET {base-url}/Thing?referenced:InstanceType={id}`
- If the search token does contain a forward slash it is assumed to be an absolute reference and no `:InstanceType` will be appended:  
    `GET {base-url}/Thing?referenced={uri}`


### Weirdnesses

_Observation_ has the search parameter `name-value-[x]` which can adapt to certain types (to replace `[x]`).
This has yet to be implemented.
